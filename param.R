#### functions handling parameter manipulation. par2nM nM2par etc

### for info on models see Celeux and Govaert 1995

#' @include Cholesky.R
#' @include weight.R


## map lower.tri to vec
ld. <- function(mat){
    x <- mat[lower.tri(mat, diag=FALSE)]
}

## map vec to lower.tri
dl. <- function(d,x,p){
    mat <- diag(1,p)
    mat[lower.tri(mat,diag=FALSE)] <- x
    mat %*% diag(d) %*% t(mat)
}


#' normal multivariate mixture model to parameter for MLE
#'
#' \code{nMm2par} returns vector of parameters of norMmix objects
#'
#' This transformation forms a vector from the parameters of a normal
#' mixture. These consist of weights, means and covariance matrices.
#' Weights are transformed according to 'trafo' param; means are
#' unchanged.
#' Cov mats are given as D and L from the LDLt decomposition
#'
#' @seealso n2p
#'
#' @param obj list containing sig= covariance matrix array, mu= mean vector matrix, w= weights, k= number of clusters, p= dimension
#' @param trafo either "clr1" or "logit"
#' @param model one of "asdf..."
#' @examples
#' A  <- MW2nm4
#' nMm2par( A, trafo="clr1", model=A$model )
#'
#' @export

nMm2par <- function(obj,
            trafo=c("clr1", "logit"),
            model=c("EII","VII","EEI","VEI","EVI",
                "VVI","EEE","VEE","EVV","VVV")
            ){

    #transferring values of obj to handier variables
    w <- obj$weight
    mu <- obj$mu
    sig <- obj$Sigma
    p <- obj$dim
    k <- obj$k

    trafo <- match.arg(trafo)
    model <- match.arg(model)

    ##checks

    # weights

    stopifnot( isTRUE(all.equal(sum(w),1)), (length(w)==k),
          is.numeric(w), is.finite(w) )


    # mu

    stopifnot( (dim(mu)==c(p,k)), (is.numeric(mu)),
          is.matrix(mu), is.finite(mu) )


    # Sigma

    stopifnot( (dim(sig)==c(p,p,k)), (is.numeric(sig)),
          length(dim(sig))==3, is.array(sig) )
    stopifnot( isTRUE( all( apply(sig,3, function(j) (ldl(j)$Diag >= 0 )))))


    #output vector of parameter values

    c(
      w <- switch(trafo, #weights either logit or centered log ratio
        "logit" = logit(w),

            "clr1" = clr1(w),

        stop("Error in weight trafo, ",trafo)
            ),
      mu, #means
      Sigma <- switch(model, #model dependent covariance values
        "EII" = log(sig[1,1,1]),

        "VII" = log(sig[1,1,]),

        "EEI" = {
            D.temp <- diag(sig[,,1])
            alpha <- log(prod(D.temp)^(1/p))
            D. <- log(D.temp) - alpha
            c(alpha, D.[-1])
            },

        "VEI" = {
            alpha <- (apply(sig,3,function(j) prod(diag(j))^(1/p)))
            D. <- (diag(sig[,,1]))/alpha[1]
            c(log(alpha), log(D.[-1]))
            },

        "EVI" = {
            alpha <- log(prod(diag(sig[,,1]))^(1/p))
            D. <- log(apply(sig,3,diag))
            D. <- apply(D.,2, function(j) j-sum(j)/p)
            c(alpha,D.[-1,])
            },

        "VVI" = {
            alpha <- apply(sig,3, function(j) det(j)^(1/p))
            D.temp <- apply(sig,3,diag)
            D. <- D.temp %*% diag(1/alpha,k) # this is fastest?? https://stackoverflow.com/questions/20596433/how-to-divide-each-row-of-a-matrix-by-elements-of-a-vector-in-r
            c(log(alpha),log(D.[-1,]))
            },

        "EEE" = {
            alpha <- prod( ldl(sig[,,1])$Diag )^(1/p)
            A. <- ldl(sig[,,1])
            c(log(alpha), log(A.$Diag/alpha)[-1], ld.(A.$L))
            },

        "VEE" = {
            alpha <- apply(sig,3, function(j) prod(ldl(j)$Diag )^(1/p))
            A. <- ldl(sig[,,1])
            c(log(alpha), log(A.$Diag/alpha[1])[-1], ld.(A.$L))
            },

        "EVV" = {
            alpha <- prod( ldl(sig[,,1])$Diag )^(1/p)
            D. <- apply(sig,3, function(j) ldl(j)$Diag)
            D. <- apply(D.,2, function(j) j/(prod(j)^(1/p)))
            L. <- apply(sig,3, function(j) ld.( ldl(j)$L ))
            c(log(alpha), log(D.)[-1,], L.)
            },

        "VVV" = {
            alpha <- apply(sig,3, function(j) prod(ldl(j)$Diag )^(1/p))
            D. <- apply(sig,3, function(j) ldl(j)$Diag)
            D. <- D. %*% diag(1/alpha,k)
            L. <- apply(sig,3, function(j) ld.( ldl(j)$L ))
            c(log(alpha), log(D.)[-1,], L.)
            },

        stop("invalid argument in 'model'")
        )
    )
}


#' wrapper function for nMm objs in zmarrwandMm
#'
#' \code{n2p} returns same as nMm2par with clr1
#'
#' @export
n2p <-
## these were in ./zmarrwandnMm.R :
n2m <- # <- drop this name and rather use
nc2p <- function(obj) nMm2par(obj , trafo="clr1",  obj$model)

ln2m <- # <- drop this, and rather use
nl2p <- function(obj) nMm2par(obj , trafo="logit", obj$model)



#' transform of parameter vector to normal mixture
#'
#' \code{par2nMm} returns list containing weight, mu, Sigma, k, dim
#'
#' this is the inverse function to nMm2par. Given a numeric vector
#' dimension and cluster number this function reconstructs a normal mixture
#' object.
#'
#' @param par. numeric vector of parameters
#' @param p dimension of space
#' @param trafo either "clr1" or "logit"
#' @param model See description
#'
#' @return returns this list: list(weight=w, mu=mu, Sigma=Sigma, k=k, dim=p)
#' @export

par2nMm <- function(par., p, k,
            trafo = c("clr1", "logit"),
            model = c("EII","VII","EEI","VEI","EEE",
                    "VEE","EVI","VVI","EVV","VVV")
            )
{
    trafo <- match.arg(trafo)
    model <- match.arg(model)

    p <- as.integer(p)
    k <- as.integer(k)

    # start of relevant parameters:

    f <- k + p*k # weights -1 + means +1 => start of alpha

    f1 <- f # end of alpha if uniform
    f2 <- f+k-1L # end of alpha if var

    f1.1 <- f1 +1L #start of D. if alpha unif.
    f2.1 <- f1 + k # start of D. if alpha varialbe

    f11 <- f1 + p -1 # end of D. if D. uniform and alpha uniform
    f12 <- f1 + p*k -k # end D. if D. var and alpha unif.
    f21 <- f2 + p -1 # end of D. if D. uniform and alpha variable
    f22 <- f2 + p*k -k # end of D. if D.var and alpha var

    f11.1 <- f11 +1L # start of L if alpha unif D unif
    f21.1 <- f21 +1L # start of L if alpha var D unif
    f12.1 <- f12 +1L # start of L if alpha unif D var
    f22.1 <- f22 +1L # start of L if alpha var D var

    f111 <- f11 + p*(p-1)/2 # end of L if alpha unif D unif
    f211 <- f21 + p*(p-1)/2 # end of L if alpha var D unif
    f121 <- f12 + k*p*(p-1)/2 # end of L if alpha unif D var
    f221 <- f22 + k*p*(p-1)/2 # end of L if alpha var D var

    #only important ones are f1.2, f1.3, f2.2, f2.3

    w.temp <- if(k==1) vector() else par.[1:(k-1)]
    w <- switch(trafo,
                "logit" = logitinv(w.temp),
                "clr1"  = clr1inv (w.temp),
                stop("invalid 'trafo'": trafo))

    mu <- matrix(par.[k:(k+p*k-1)], p, k)

### FIXME: Alternatively, instead of Sigma, compute  chol(Sigma) = D^{1/2} L'  as Sigma = LDL'

    Sigma <- switch(model,
    # diagonal cases
    "EII" = {
        lambda <- exp(par.[f])
        array( rep(diag(lambda, p),k), c(p,p,k) )
        },

    "VII" = {
        lambda <- exp(par.[f:f2])
        array(unlist(lapply( lambda, function(j) diag(j,p) )), c(p,p,k))
        },

    "EEI" = {
        par.[f:f11] <- exp(par.[f:f11])
        lambda <- par.[f]
        D. <- par.[f1.1:f11]
        D. <- c(1/prod(D.), D.)
        D. <- D./(prod(D.)^(1/p))
        array( rep(diag(lambda*D.),k), c(p,p,k) )
        },

    "VEI" = {
        par.[f:f21] <- exp(par.[f:f21])
        lambda <- par.[f:f2]
        D. <- par.[f2.1:f21]
        D. <- c(1/prod(D.), D.)
        D. <- D./(prod(D.)^(1/p))
        D. <- tcrossprod(D.,lambda)
        array( apply(D.,2, diag), c(p,p,k))
        },

    "EVI" = {
        par.[f:f12] <- exp(par.[f:f12])
        lambda <- par.[f]
        D. <- matrix(par.[f1.1:f12],p-1,k)
        D. <- apply(D., 2, function(j) c(1/prod(j), j))
        D. <- apply(D.,2, function(j) j/(prod(j)^(1/p)))
        D. <- D.*lambda
        array( apply(D.,2, diag), c(p,p,k))
        },

    "VVI" = {
        par.[f:f22] <- exp(par.[f:f22])
        lambda <- par.[f:f2]
        D. <- matrix(par.[f2.1:f22],p-1,k)
        D. <- apply(D., 2, function(j) c(1/prod(j), j))
        D. <- apply(D.,2, function(j) j/(prod(j)^(1/p)))
        D. <- D. %*% diag(lambda,k)
        array( apply(D.,2, diag), c(p,p,k))
        },

    # variable cases

    "EEE" = {
        par.[f:f11] <- exp(par.[f:f11])
        lambda <- par.[f]
        D. <- par.[f1.1:f11]
        D. <- c(1/prod(D.), D.)
        D. <- D./(prod(D.)^(1/p))
        D. <- D.*lambda
        L. <- par.[f11.1:f111]
        A. <- dl.(D.,L.,p)
        sig <- array(0, c(p,p,k))
        for (i in 1:k){
            sig[,,i] <- A.
        }
        sig
        },

    "VEE" = {
        par.[f:f21] <- exp(par.[f:f21])
        lambda <- par.[f:f2]
        D. <- par.[f2.1:f21]
        D. <- c(1/prod(D.), D.)
        D. <- D./(prod(D.)^(1/p))
        D. <- tcrossprod(D.,lambda)
        f3 <- (p*(p-1)/2)
        L. <- par.[f21.1:f211]
        sig <- array(0, c(p,p,k))
        for (i in 1:k){
            sig[,,i] <- dl.(D.[,i],L.,p)
        }
        sig
        },

    "EVV" = {
        par.[f:f12] <- exp(par.[f:f12])
        lambda <- par.[f]
        D. <- matrix(par.[f1.1:f12],p-1,k)
        D. <- apply(D., 2, function(j) c(1/prod(j), j))
        D. <- apply(D.,2,function(j) j/(prod(j)^(1/p))) * lambda
        f3 <- (p*(p-1)/2)
        L.temp <- matrix(par.[f12.1:f121],f3,k)
        sig <- array(0, c(p,p,k))
        for (i in 1:k) {
            sig[,,i] <- dl.(D.[,i],L.temp[,i],p)
        }
        sig
        },

    "VVV" = {
        par.[f:f22] <- exp(par.[f:f22])
        lambda <- par.[f:f2]
        D. <- matrix(par.[f2.1:f22],p-1,k)
        D. <- apply(D., 2, function(j) c(1/prod(j), j))
        D. <- apply(D.,2, function(j) j/(prod(j)^(1/p)))
        D. <- D. %*% diag(lambda,k)
        f3 <- (p*(p-1)/2)
        L.temp <- matrix(par.[f22.1:f221],f3,k)
        sig <- array(0, c(p,p,k))
        for (i in 1:k) {
            sig[,,i] <- dl.(D.[,i],L.temp[,i],p)
        }
        sig},
    stop("error in Sigma switch statement")
    )

    name <- sprintf("model = %s , clusters = %s", model, k)

    structure(
        name = name,
        class = "norMmix",
        list( mu=mu, Sigma=Sigma, weight=w, k=k, dim=p , model=model)
        )
}



